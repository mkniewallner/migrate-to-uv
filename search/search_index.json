{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p><code>migrate-to-uv</code> migrates a project to uv from another package manager.</p> <p>Try it now:</p> <pre><code># With uv\nuvx migrate-to-uv\n\n# With pipx\npipx run migrate-to-uv\n</code></pre> <p>The following package managers are supported:</p> <ul> <li>Poetry (including projects   using PEP 621 in Poetry 2.0+)</li> <li>Pipenv</li> <li>pip-tools</li> <li>pip</li> </ul> <p>More package managers (e.g., setuptools) could be implemented in the future.</p>"},{"location":"#features","title":"Features","text":"<p><code>migrate-to-uv</code> converts most existing metadata from supported package managers when migrating to uv, including:</p> <ul> <li>Project metadata (<code>name</code>, <code>version</code>, <code>authors</code>, ...)</li> <li>Dependencies and optional dependencies</li> <li>Dependency groups</li> <li>Dependency sources (index, git, URL, path)</li> <li>Dependency markers</li> <li>Entry points</li> </ul> <p>Version definitions set for dependencies are also preserved, and converted to their equivalent PEP 440 for package managers that use their own syntax (for instance caret for Poetry).</p> <p>At the end of the migration, <code>migrate-to-uv</code> also generates <code>uv.lock</code> file with <code>uv lock</code> command to lock dependencies, and keeps dependencies (both direct and transitive) to the exact same versions they were locked to with the previous package manager, if a lock file was found.</p> <p>Warning</p> <p>Although <code>migrate-to-uv</code> matches current package manager definition as closely as possible when performing the migration, it is still heavily recommended to double check the end result, especially if you are migrating a package that is meant to be publicly distributed.</p> <p>If you notice a behaviour that does not match the previous package manager when migrating, please raise an issue, if not already reported.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#073-2025-06-07","title":"0.7.3 - 2025-06-07","text":""},{"location":"CHANGELOG/#bug-fixes","title":"Bug fixes","text":"<ul> <li>Use correct <code>include-group</code> name to include groups when using <code>--dependency-groups-strategy include-in-dev</code> (#283)</li> <li>[poetry] Handle <code>=</code> single equality (#288)</li> <li>[pipenv] Handle raw versions (#292)</li> </ul>"},{"location":"CHANGELOG/#072-2025-03-25","title":"0.7.2 - 2025-03-25","text":""},{"location":"CHANGELOG/#bug-fixes_1","title":"Bug fixes","text":"<ul> <li>[pipenv] Handle <code>*</code> for version (#212)</li> </ul>"},{"location":"CHANGELOG/#071-2025-02-22","title":"0.7.1 - 2025-02-22","text":""},{"location":"CHANGELOG/#bug-fixes_2","title":"Bug fixes","text":"<ul> <li>Handle map for PEP 621 <code>license</code> field (#156)</li> </ul>"},{"location":"CHANGELOG/#070-2025-02-15","title":"0.7.0 - 2025-02-15","text":""},{"location":"CHANGELOG/#features","title":"Features","text":"<ul> <li>Add <code>--skip-uv-checks</code> to skip checking if uv is already used in a project (#118)</li> </ul>"},{"location":"CHANGELOG/#bug-fixes_3","title":"Bug fixes","text":"<ul> <li>[pip/pip-tools] Warn on unhandled dependency formats (#103)</li> <li>[pip/pip-tools] Ignore inline comments when parsing dependencies (#105)</li> <li>[poetry] Migrate scripts that use <code>scripts = { callable = \"foo:run\" }</code> format instead of crashing (#138)</li> </ul>"},{"location":"CHANGELOG/#060-2025-01-20","title":"0.6.0 - 2025-01-20","text":"<p>Existing data in <code>[project]</code> section of <code>pyproject.toml</code> is now preserved by default when migrating. If you prefer that the section is fully replaced, this can be done by setting <code>--replace-project-section</code> flag, like so:</p> <pre><code>migrate-to-uv --replace-project-section\n</code></pre> <p>Poetry projects that use PEP 621 syntax to define project metadata, for which support was added in Poetry 2.0, are now supported.</p>"},{"location":"CHANGELOG/#features_1","title":"Features","text":"<ul> <li>Preserve existing data in <code>[project]</code> section of <code>pyproject.toml</code> when migrating (#84)</li> <li>[poetry] Support migrating projects using PEP 621 (#85)</li> </ul>"},{"location":"CHANGELOG/#050-2025-01-18","title":"0.5.0 - 2025-01-18","text":""},{"location":"CHANGELOG/#features_2","title":"Features","text":"<ul> <li>[poetry] Delete <code>poetry.toml</code> after migration (#62)</li> <li>[pipenv] Delete <code>Pipfile.lock</code> after migration (#66)</li> <li>Exit if uv is detected as a package manager (#61)</li> </ul>"},{"location":"CHANGELOG/#bug-fixes_4","title":"Bug fixes","text":"<ul> <li>Ensure that lock file exists before parsing (#67)</li> </ul>"},{"location":"CHANGELOG/#documentation","title":"Documentation","text":"<ul> <li>Explain how to set credentials for private indexes (#60)</li> </ul>"},{"location":"CHANGELOG/#040-2025-01-17","title":"0.4.0 - 2025-01-17","text":"<p>When generating <code>uv.lock</code> with <code>uv lock</code> command, <code>migrate-to-uv</code> now keeps the same versions dependencies were locked to with the previous package manager (if a lock file was found), both for direct and transitive dependencies. This is supported for Poetry, Pipenv, and pip-tools.</p> <p>This new behavior can be opted out by setting <code>--ignore-locked-versions</code> flag, like so:</p> <pre><code>migrate-to-uv --ignore-locked-versions\n</code></pre>"},{"location":"CHANGELOG/#features_3","title":"Features","text":"<ul> <li>Keep locked dependencies versions when generating <code>uv.lock</code> (#56)</li> </ul>"},{"location":"CHANGELOG/#030-2025-01-12","title":"0.3.0 - 2025-01-12","text":"<p>Dependencies are now locked with <code>uv lock</code> at the end of the migration, if <code>uv</code> is detected as an executable. This new behavior can be opted out by setting <code>--skip-lock</code> flag, like so:</p> <pre><code>migrate-to-uv --skip-lock\n</code></pre>"},{"location":"CHANGELOG/#features_4","title":"Features","text":"<ul> <li>Lock dependencies at the end of migration (#46)</li> </ul>"},{"location":"CHANGELOG/#021-2025-01-05","title":"0.2.1 - 2025-01-05","text":""},{"location":"CHANGELOG/#bug-fixes_5","title":"Bug fixes","text":"<ul> <li>[poetry] Avoid crashing when an extra lists a non-existing dependency (#30)</li> </ul>"},{"location":"CHANGELOG/#020-2025-01-05","title":"0.2.0 - 2025-01-05","text":""},{"location":"CHANGELOG/#features_5","title":"Features","text":"<ul> <li>Support migrating projects using <code>pip</code> and <code>pip-tools</code> (#24)</li> <li>[poetry] Migrate data from <code>packages</code>, <code>include</code> and <code>exclude</code> to Hatch build backend (#16)</li> </ul>"},{"location":"CHANGELOG/#012-2025-01-02","title":"0.1.2 - 2025-01-02","text":""},{"location":"CHANGELOG/#bug-fixes_6","title":"Bug fixes","text":"<ul> <li>[pipenv] Correctly update <code>pyproject.toml</code> (#19)</li> <li>Do not insert <code>[tool.uv]</code> if empty (#17)</li> </ul>"},{"location":"CHANGELOG/#011-2024-12-26","title":"0.1.1 - 2024-12-26","text":""},{"location":"CHANGELOG/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>Fix documentation publishing and package metadata (#3)</li> </ul>"},{"location":"CHANGELOG/#010-2024-12-26","title":"0.1.0 - 2024-12-26","text":"<p>Initial release, with support for Poetry and Pipenv.</p>"},{"location":"CONTRIBUTING/","title":"Contributing","text":""},{"location":"CONTRIBUTING/#setup","title":"Setup","text":"<p>Rust is required to build the project.</p>"},{"location":"CONTRIBUTING/#linting-and-formatting","title":"Linting and formatting","text":"<p>The project uses several tools from the Rust ecosystem to check for common linting issues, and ensure that the code is correctly formatted, like:</p> <ul> <li>clippy for linting</li> <li>rustfmt for formatting</li> </ul> <p>pre-commit is used to ensure that all tools are run at commit time. You can install hooks in the project with:</p> <pre><code>pre-commit install\n</code></pre> <p>This will automatically run the relevant git hooks based on the files that are modified whenever you commit.</p> <p>You can also run all hooks manually without committing with:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":"<p>Both unit and integration tests are used to ensure that the code work as intended. They can be run with:</p> <pre><code>make test\n</code></pre> <p>Unit tests are located in modules, alongside the code, under <code>src</code> directory, and can be run with:</p> <pre><code>make test-unit\n</code></pre> <p>Integration tests are located under <code>tests</code> directory, and can be run with:</p> <pre><code>make test-integration\n</code></pre> <p>As integration tests depend on uv for performing locking, make sure that it is present on your machine before running them.</p>"},{"location":"CONTRIBUTING/#snapshots","title":"Snapshots","text":"<p>Both unit and integration tests use snapshot testing through insta, to assert things like the content of files or command line outputs. Those snapshots can either be asserted right into the code, or against files stored in <code>snapshots</code> directories, for instance:</p> <pre><code>#[test]\nfn test_with_snapshots() {\n    // Inline snapshot\n    insta::assert_snapshot!(foo(), @r###\"\n        [project]\n        name = \"foo\"\n        version = \"0.0.1\"\n        \"###);\n\n    // External snapshot, stored under `snapshots` directory\n    insta::assert_snapshot!(foo());\n}\n</code></pre> <p>In both cases, if you update code that changes the output of snapshots, you will be prompted to review the updated snapshots with:</p> <pre><code>cargo insta review\n</code></pre> <p>You can then accept the changes, if they look correct according to the changed code.</p>"},{"location":"CONTRIBUTING/#documentation","title":"Documentation","text":"<p>Documentation is built using mkdocs and mkdocs-material.</p> <p>It can be run locally with uv by using:</p> <pre><code>make doc-serve\n</code></pre>"},{"location":"supported-package-managers/","title":"Supported package managers","text":"<p><code>migrate-to-uv</code> supports multiple package managers. By default, it tries to auto-detect the package manager based on the files (and their content) used by the package managers it supports. If you need to enforce a specific package manager to be used, use <code>--package-manager</code>.</p>"},{"location":"supported-package-managers/#poetry","title":"Poetry","text":"<p>Note</p> <p><code>migrate-to-uv</code> supports migrating both projects that use Poetry-specific syntax for defining project metadata, and projects that use PEP 621, added in Poetry 2.0.</p> <p>All existing Poetry metadata should be converted to uv when performing the migration:</p> <ul> <li>Project metadata (<code>name</code>, <code>version</code>, <code>authors</code>, ...)</li> <li>Dependencies and dependency groups   (PyPI, path, git, URL)</li> <li>Dependency extras (also known as optional dependencies)</li> <li>Dependency sources</li> <li>Dependency markers (including   <code>python</code> and <code>platform</code>)</li> <li>Multiple constraints dependencies</li> <li>Package distribution metadata (<code>packages</code>, <code>include</code> and <code>exclude</code>)</li> <li>Supported Python versions</li> <li>Scripts and   plugins (also known as entry points)</li> </ul> <p>Version definitions set for dependencies are also preserved, and converted to their equivalent PEP 440 format used by uv, even for Poetry-specific version specification (e.g., caret (<code>^</code>) and tilde (<code>~</code>)).</p>"},{"location":"supported-package-managers/#build-backend","title":"Build backend","text":"<p>As uv does not yet have a stable build backend (see astral-sh/uv#8779 for more details), when performing the migration for libraries, <code>migrate-to-uv</code> sets Hatch as a build backend, migrating:</p> <ul> <li>Poetry <code>packages</code> and <code>include</code> to Hatch <code>include</code></li> <li>Poetry <code>exclude</code> to Hatch <code>exclude</code></li> </ul> <p>Note</p> <p>Path rewriting, defined with <code>to</code> in <code>packages</code> for Poetry, is also migrated to Hatch by defining sources in wheel target.</p> <p>Once uv build backend is out of preview and considered stable, it will be used for the migration.</p>"},{"location":"supported-package-managers/#pipenv","title":"Pipenv","text":"<p>All existing Pipenv metadata should be converted to uv when performing the migration:</p> <ul> <li>Dependencies and development dependencies (PyPI,   path, git, URL)</li> <li>Package category groups</li> <li>Package indexes</li> <li>Dependency markers</li> <li>Supported Python versions</li> </ul>"},{"location":"supported-package-managers/#pip-tools","title":"pip-tools","text":"<p>Most pip-tools metadata is converted to uv when performing the migration.</p> <p>By default, <code>migrate-to-uv</code> will search for:</p> <ul> <li>production dependencies in <code>requirements.in</code></li> <li>development dependencies in <code>requirements-dev.in</code></li> </ul> <p>If your project uses different file names, or defines production and/or development dependencies across multiple files, you can specify the names of the files using <code>--requirements-file</code> and <code>--dev-requirements-file</code> (both can be specified multiple times), for instance:</p> <pre><code>migrate-to-uv \\\n  --requirements-file requirements-prod.in \\\n  --dev-requirements-file requirements-dev.in \\\n  --dev-requirements-file requirements-docs.in\n</code></pre>"},{"location":"supported-package-managers/#missing-features","title":"Missing features","text":"<ul> <li>Dependencies that do not follow PEP 508 specification are not yet handled</li> <li>References to other requirement files (e.g., <code>-r other-requirements.in</code>) are not supported, but the requirements file   can manually be set with <code>--requirements-file</code> or   <code>--dev-requirements-file</code></li> <li>Index URLs are not yet migrated</li> </ul>"},{"location":"supported-package-managers/#pip","title":"pip","text":"<p>Most pip metadata is converted to uv when performing the migration.</p> <p>By default, <code>migrate-to-uv</code> will search for:</p> <ul> <li>production dependencies in <code>requirements.txt</code></li> <li>development dependencies in <code>requirements-dev.txt</code></li> </ul> <p>If your project uses different file names, or defines production and/or development dependencies across multiple files, you can specify the names of the files <code>--requirements-file</code> and <code>--dev-requirements-file</code> (both can be specified multiple times), for instance:</p> <pre><code>migrate-to-uv \\\n  --requirements-file requirements-prod.txt \\\n  --dev-requirements-file requirements-dev.txt \\\n  --dev-requirements-file requirements-docs.txt\n</code></pre>"},{"location":"supported-package-managers/#missing-features_1","title":"Missing features","text":"<ul> <li>Dependencies that do not follow PEP 508 specification are not yet handled</li> <li>References to other requirement files (e.g., <code>-r other-requirements.txt</code>) are not supported, but the requirements file   can manually be set with <code>--requirements-file</code> or   <code>--dev-requirements-file</code></li> <li>Index URLs are not yet migrated</li> </ul>"},{"location":"usage-and-configuration/","title":"Usage and configuration","text":""},{"location":"usage-and-configuration/#basic-usage","title":"Basic usage","text":"<pre><code># With uv\nuvx migrate-to-uv\n\n# With pipx\npipx run migrate-to-uv\n</code></pre>"},{"location":"usage-and-configuration/#configuration","title":"Configuration","text":""},{"location":"usage-and-configuration/#project-path","title":"Project path","text":"<p>By default, <code>migrate-to-uv</code> uses the current directory to search for the project to migrate. If the project is in a different path, you can set the path to a directory as a positional argument, like so:</p> <pre><code># Relative path\nmigrate-to-uv subdirectory\n\n# Absolute path\nmigrate-to-uv /home/foo/project\n</code></pre>"},{"location":"usage-and-configuration/#arguments","title":"Arguments","text":"<p>While <code>migrate-to-uv</code> tries, as much as possible, to match what the original package manager defines for a project when migrating the metadata to uv, there are features that could be present in a package manager that does not exist in uv, or behave differently. Mainly for those reasons, <code>migrate-to-uv</code> offers a few options.</p>"},{"location":"usage-and-configuration/#-dry-run","title":"<code>--dry-run</code>","text":"<p>This runs the migration, but without modifying the files. Instead, it prints the changes that would have been made in the terminal.</p> <p>Example:</p> <pre><code>migrate-to-uv --dry-run\n</code></pre>"},{"location":"usage-and-configuration/#-skip-lock","title":"<code>--skip-lock</code>","text":"<p>By default, <code>migrate-to-uv</code> locks dependencies with <code>uv lock</code> at the end of the migration. This flag disables this behavior.</p> <p>Example:</p> <pre><code>migrate-to-uv --skip-lock\n</code></pre>"},{"location":"usage-and-configuration/#-skip-uv-checks","title":"<code>--skip-uv-checks</code>","text":"<p>By default, <code>migrate-to-uv</code> will exit early if it sees that a project is already using <code>uv</code>. This flag disables that behavior, allowing <code>migrate-to-uv</code> to run on a <code>pyproject.toml</code> which already has <code>uv</code> configured.</p> <p>Note that the project must also have a valid non-<code>uv</code> package manager configured, or else it will fail to generate the <code>uv</code> configuration.</p> <p>Example:</p> <pre><code>migrate-to-uv --skip-uv-checks\n</code></pre>"},{"location":"usage-and-configuration/#-ignore-locked-versions","title":"<code>--ignore-locked-versions</code>","text":"<p>By default, when locking dependencies with <code>uv lock</code>, <code>migrate-to-uv</code> keeps dependencies to the versions they were locked to with the previous package manager, if it supports lock files, and if a lock file is found. This behavior can be disabled, in which case dependencies will be locked to the highest possible versions allowed by the dependencies constraints.</p> <p>Example:</p> <pre><code>migrate-to-uv --ignore-locked-versions\n</code></pre>"},{"location":"usage-and-configuration/#-replace-project-section","title":"<code>--replace-project-section</code>","text":"<p>By default, existing data in <code>[project]</code> section of <code>pyproject.toml</code> is preserved when migrating. This flag allows completely replacing existing content.</p> <p>Example:</p> <pre><code>migrate-to-uv --replace-project-section\n</code></pre>"},{"location":"usage-and-configuration/#-package-manager","title":"<code>--package-manager</code>","text":"<p>By default, <code>migrate-to-uv</code> tries to auto-detect the package manager based on the files (and their content) used by the package managers it supports. If auto-detection does not work in some cases, or if you prefer to explicitly specify the package manager, this option could be used.</p> <p>Example:</p> <pre><code>migrate-to-uv --package-manager poetry\n</code></pre>"},{"location":"usage-and-configuration/#-dependency-groups-strategy","title":"<code>--dependency-groups-strategy</code>","text":"<p>Most package managers that support dependency groups install dependencies from all groups when performing installation. By default, uv will only install <code>dev</code> one.</p> <p>In order to match the workflow in the current package manager as closely as possible, by default, <code>migrate-to-uv</code> will move each dependency group to its corresponding one in uv, and set all dependency groups in <code>default-groups</code> under <code>[tool.uv]</code> section (unless the only dependency group is <code>dev</code> one, as this is already uv's default).</p> <p>If this is not desirable, it is possible to change the strategy by using <code>--dependency-groups-strategy &lt;VALUE&gt;</code>, where <code>&lt;VALUE&gt;</code> can be one of the following:</p> <ul> <li><code>set-default-groups</code> (default): Move each dependency group to its corresponding uv dependency group, and add all   dependency groups in <code>default-groups</code> under <code>[tool.uv]</code> section (unless the only dependency group is <code>dev</code> one, as   this is already uv's default)</li> <li><code>include-in-dev</code>:  Move each dependency group to its corresponding uv dependency group, and reference all dependency   groups (others than <code>dev</code> one) in <code>dev</code> dependency group by using <code>{ include-group = \"&lt;group&gt;\" }</code></li> <li><code>keep-existing</code>: Move each dependency group to its corresponding uv dependency group, without any further action</li> <li><code>merge-into-dev</code>: Merge dependencies from all dependency groups into <code>dev</code> dependency group</li> </ul> <p>Example:</p> <pre><code>migrate-to-uv --dependency-groups-strategy include-in-dev\n</code></pre>"},{"location":"usage-and-configuration/#-requirements-file","title":"<code>--requirements-file</code>","text":"<p>Names of the production requirements files to look for, for projects using <code>pip</code> or <code>pip-tools</code>. The argument can be set multiple times, if there are multiple files.</p> <p>Example:</p> <pre><code>migrate-to-uv --requirements-file requirements.txt --requirements-file more-requirements.txt\n</code></pre>"},{"location":"usage-and-configuration/#-dev-requirements-file","title":"<code>--dev-requirements-file</code>","text":"<p>Names of the development requirements files to look for, for projects using <code>pip</code> or <code>pip-tools</code>. The argument can be set multiple times, if there are multiple files.</p> <p>Example:</p> <pre><code>migrate-to-uv --dev-requirements-file requirements-dev.txt --dev-requirements-file requirements-docs.txt\n</code></pre>"},{"location":"usage-and-configuration/#-keep-current-data","title":"<code>--keep-current-data</code>","text":"<p>Keep the current package manager data (lock file, sections in <code>pyproject.toml</code>, ...) after the migration, if you want to handle the cleaning yourself, or want to compare the differences first.</p>"},{"location":"usage-and-configuration/#authentication-for-private-indexes","title":"Authentication for private indexes","text":"<p>By default, <code>migrate-to-uv</code> generates <code>uv.lock</code> with <code>uv lock</code> to lock dependencies. If you currently use a package manager with private indexes, credentials will need to be set for locking to work properly. This can be done by setting the same environment variables as uv expects for private indexes.</p> <p>Since the names of the indexes in uv should be the same as the ones in the current package manager before the migration, you should be able to adapt the environment variables based on what you previously used.</p> <p>For instance, if you currently use Poetry and have:</p> <pre><code>[[tool.poetry.source]]\nname = \"foo-bar\"\nurl = \"https://private-index.example.com\"\npriority = \"supplementary\"\n</code></pre> <p>Credentials would be set with the following environment variables:</p> <ul> <li><code>POETRY_HTTP_BASIC_FOO_BAR_USERNAME</code></li> <li><code>POETRY_HTTP_BASIC_FOO_BAR_PASSWORD</code></li> </ul> <p>For uv, this would translate to:</p> <ul> <li><code>UV_INDEX_FOO_BAR_USERNAME</code></li> <li><code>UV_INDEX_FOO_BAR_PASSWORD</code></li> </ul> <p>To forward those credentials to <code>migrate-to-uv</code>, you can either export them beforehand, or set the environment variables when invoking the command:</p> <pre><code># Either\nexport UV_INDEX_FOO_BAR_USERNAME=&lt;username&gt;\nexport UV_INDEX_FOO_BAR_PASSWORD=&lt;password&gt;\nmigrate-to-uv\n\n# Or\nUV_INDEX_FOO_BAR_USERNAME=&lt;username&gt; \\\n  UV_INDEX_FOO_BAR_PASSWORD=&lt;password&gt; \\\n  migrate-to-uv\n</code></pre>"}]}